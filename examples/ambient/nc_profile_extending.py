"""
Extend a profile's CTD data to deeper depths
============================================

Use the TAMOC ambient module to open a Profile object, compute some buoyancy
frequencies and then artificially extend the profile to deeper depths while
maintaining a fixed buoyancy frequency.

Notes
-----
There are any number of ways that CTD data could be artificially extended to
deeper than the measured depths.  This script demonstrates one rational 
method coded in the `ambient.Profile` class and documented in the class 
method `ambient.Profile.extend_profile_deeper()`.

Requires
--------
This script reads data from a netCDF object already in the format of a 
TAMOC `ambient.Profile` object, stored in the file::

    ./Profiles/Profiles/BM54.nc

If this file is not yet present in your directory structure, it can be 
generated by the `profile_from_ctd` script.  To execute that file, change
directory at the command promt to the `./Profiles` root directory and at the 
IPython prompt execute::

    >>> run profile_from_ctd

Returns
-------
This script generates a new `ambient.Profile` object, whose netCDF file is
written to the file::

    ./Profiles/Profiles/BM54_deeper.nc

"""
# S. Socolofsky, July 2013, Texas A&M University <socolofs@tamu.edu>.

from __future__ import (absolute_import, division, print_function, 
                        unicode_literals)

from tamoc import ambient #old_ambient as ambient
from tamoc import seawater

from netCDF4 import date2num, num2date
from datetime import datetime
from time import ctime

import numpy as np
import matplotlib.pyplot as plt
import os

    
def get_ctd_profile():
    """
    Load the ASCII CTD Data into an `ambient.Profile` object.
    
    This function performs the steps in ./profile_from_ctd.py to read in the
    CTD data and create a Profile object.  This is the data set that will be
    used to demonstrate how to append data to a Profile object.
    
    """
    # Get the path to the input file
    __location__ = os.path.realpath(os.path.join(os.getcwd(),
                                    os.path.dirname(__file__), 
                                    '../../tamoc/data'))
    dat_file = os.path.join(__location__,'ctd_BM54.cnv')
    
    # Load in the data using numpy.loadtxt
    raw = np.loadtxt(dat_file, comments = '#', skiprows = 175, 
                     usecols = (0, 1, 3, 8, 9, 10, 12))
    
    # Describe the organization of the data in raw.  
    var_names = ['temperature', 'pressure', 'wetlab_fluorescence', 'z', 
                 'salinity', 'density', 'oxygen']
    var_units = ['deg C', 'db', 'mg/m^3', 'm', 'psu', 'kg/m^3', 'mg/l']
    z_col = 3
    
    # Clean the profile to remove reversals in the depth coordinate
    data = ambient.extract_profile(raw, z_col, 50.0)
    
    # Convert the profile data to standard units in TAMOC
    profile, units = ambient.convert_units(data, var_units)
    
    # Create an empty netCDF4-classic dataset to store this CTD data
    __location__ = os.path.realpath(os.path.join(os.getcwd(),
                                    os.path.dirname(__file__), 
                                    '../../tamoc/test/output'))
    nc_file = os.path.join(__location__,'BM54.nc')
    summary = 'Dataset created by profile_from_ctd in the ./bin directory' \
              + ' of TAMOC'
    source = 'R/V Brooks McCall, station BM54'
    sea_name = 'Gulf of Mexico'
    p_lat = 28.0 + 43.945 / 60.0
    p_lon = 360 - (88.0 + 22.607 / 60.0) 
    p_time = date2num(datetime(2010, 5, 30, 18, 22, 12), 
                      units = 'seconds since 1970-01-01 00:00:00 0:00', 
                      calendar = 'julian')
    nc = ambient.create_nc_db(nc_file, summary, source, sea_name, p_lat, 
                              p_lon, p_time)
    
    # Insert the CTD data into the netCDF dataset
    comments = ['measured'] * len(var_names)
    nc = ambient.fill_nc_db(nc, profile, var_names, units, comments, z_col)
    
    # Create an ambient.Profile object for this dataset
    bm54 = ambient.Profile(nc, chem_names=['oxygen'])
    
    # Return the Profile object
    return bm54

if __name__ == '__main__':
        
    # Get the ambient.Profile object with the original CTD data
    ctd = get_ctd_profile()
    
    # Print the buoyancy frequency at a few selected depths
    z = np.array([500., 1000., 1500.])
    N = ctd.buoyancy_frequency(z)
    print('Buoyancy frequency is: ')
    for i in range(len(z)):
        print('    N(%d m) = %g (1/s) ' % (z[i], N[i]))
    
    # Plot the potential density profile and corresponding buoyancy frequency
    z_min = ctd.z_min
    z_max = ctd.z_max
    z = np.linspace(z_min, z_max, 500)
    ts = ctd.get_values(z, ['temperature', 'salinity'])
    rho = seawater.density(ts[:,0], ts[:,1], 101325.)
    N = ctd.buoyancy_frequency(z)
    fig = plt.figure(3)
    plt.clf()
    ax1 = plt.subplot(121)
    ax1.plot(rho, z)
    ax1.set_xlabel('Potential density, (kg/m^3)')
    ax1.set_ylabel('Depth, (m)')
    ax1.set_ylim([0., 2500.])
    ax1.invert_yaxis()
    ax2 = plt.subplot(122)
    ax2.plot(N, z)
    ax2.set_xlabel('N, (1/s)')
    ax2.set_ylim([0., 2500.])
    ax2.invert_yaxis()
    plt.show()
    
    # Get the path to the output file
    __location__ = os.path.realpath(os.path.join(os.getcwd(),
                                    os.path.dirname(__file__), 
                                    '../../tamoc/test/output'))
    
    # Extend the CTD profile to 2500 m
    dat_file = os.path.join(__location__,'BM54_deeper.nc')
    ctd.extend_profile_deeper(2500., dat_file)
    
    # Plot the new potential density and buoyancy frequency profiles
    z_min = ctd.nc.variables['z'].valid_min
    z_max = ctd.nc.variables['z'].valid_max
    z = np.linspace(z_min, z_max, 750)
    ts = ctd.get_values(z, ['temperature', 'salinity'])
    rho = seawater.density(ts[:,0], ts[:,1], 101325.)
    N = ctd.buoyancy_frequency(z)
    fig = plt.figure(4)
    plt.clf()
    ax1 = plt.subplot(121)
    ax1.plot(rho, z)
    ax1.set_xlabel('Potential density, (kg/m^3)')
    ax1.set_ylabel('Depth, (m)')
    ax1.invert_yaxis()
    ax2 = plt.subplot(122)
    ax2.plot(N, z)
    ax2.set_xlabel('N, (1/s)')
    ax2.invert_yaxis()
    plt.show()
    
    ctd.close_nc()

    